/* tslint:disable */
/* eslint-disable */
/**
 * Malloy Publisher - Semantic Model Serving API
 * The Malloy Publisher - Semantic Model Serving API provides comprehensive access to Malloy packages and their associated resources. A Malloy package is a directory containing Malloy models (.malloy files), Malloy notebooks (.malloynb files), and embedded databases (.parquet files) with a malloy-publisher.json manifest at the package\'s root directory.  ## Key Features  - **Project Management**: Create and manage projects with their associated packages and connections - **Package Lifecycle**: Full CRUD operations for Malloy packages and their versions - **Model & Notebook Access**: Retrieve and execute Malloy models and notebooks - **Connection Management**: Secure database connection configuration and testing - **Query Execution**: Execute queries against models and retrieve results - **Watch Mode**: Real-time file watching for development workflows  ## Resource Hierarchy  The API follows a hierarchical resource structure: ``` Projects ├── Connections └── Packages     ├── Models     ├── Notebooks     └── Databases ```  For examples, see the Malloy samples packages (https://github.com/malloydata/malloy-samples) repository. 
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { Connection } from '../models';
// @ts-ignore
import type { CreateConnection201Response } from '../models';
// @ts-ignore
import type { CreateConnection409Response } from '../models';
// @ts-ignore
import type { PostSqlsourceRequest } from '../models';
// @ts-ignore
import type { QueryData } from '../models';
// @ts-ignore
import type { Schema } from '../models';
// @ts-ignore
import type { SqlSource } from '../models';
// @ts-ignore
import type { Table } from '../models';
// @ts-ignore
import type { TableSource } from '../models';
// @ts-ignore
import type { TemporaryTable } from '../models';
// @ts-ignore
import type { UpdateConnectionRequest } from '../models';
/**
 * ConnectionsApi - axios parameter creator
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new database connection in the specified project. 
         * @summary Create a new database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {Connection} connection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (projectName: string, connectionName: string, connection: Connection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('createConnection', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('createConnection', 'connectionName', connectionName)
            // verify required parameter 'connection' is not null or undefined
            assertParamExists('createConnection', 'connection', connection)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a database connection from the project. 
         * @summary Delete a database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection: async (projectName: string, connectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('deleteConnection', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('deleteConnection', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific database connection within a project. This includes connection configuration, credentials (if accessible), and metadata. Useful for inspecting connection settings and troubleshooting connectivity issues. 
         * @summary Get connection details
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection: async (projectName: string, connectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getConnection', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getConnection', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Executes a SQL statement against the specified database connection and returns the results. The query results include data, metadata, and execution information. 
         * @summary Execute SQL query (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getQuerydata: async (projectName: string, connectionName: string, sqlStatement?: string, _options?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getQuerydata', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getQuerydata', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/queryData`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sqlStatement !== undefined) {
                localVarQueryParameter['sqlStatement'] = sqlStatement;
            }

            if (_options !== undefined) {
                localVarQueryParameter['options'] = _options;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Creates a Malloy source from a SQL statement using the specified connection. The SQL statement is executed to generate a source definition that can be used in Malloy models. 
         * @summary Get SQL source (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSqlsource: async (projectName: string, connectionName: string, sqlStatement?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getSqlsource', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getSqlsource', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/sqlSource`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sqlStatement !== undefined) {
                localVarQueryParameter['sqlStatement'] = sqlStatement;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a table from the specified database schema. This endpoint is useful for discovering available data sources and exploring the database structure. The schema must exist in the connection for this operation to succeed. The tablePath is the full path to the table, including the schema name. 
         * @summary Get table details from database
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} schemaName Name of the schema
         * @param {string} tablePath Full path to the table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTable: async (projectName: string, connectionName: string, schemaName: string, tablePath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getTable', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getTable', 'connectionName', connectionName)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('getTable', 'schemaName', schemaName)
            // verify required parameter 'tablePath' is not null or undefined
            assertParamExists('getTable', 'tablePath', tablePath)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/schemas/{schemaName}/tables/{tablePath}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)))
                .replace(`{${"schemaName"}}`, encodeURIComponent(String(schemaName)))
                .replace(`{${"tablePath"}}`, encodeURIComponent(String(tablePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves information about a specific table or view from the database connection. This includes table schema, column definitions, and metadata. The table can be specified by either tableKey or tablePath parameters, depending on the database type. 
         * @summary Get table source information
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [tableKey] Table key
         * @param {string} [tablePath] Table path
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getTablesource: async (projectName: string, connectionName: string, tableKey?: string, tablePath?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getTablesource', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getTablesource', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/tableSource`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tableKey !== undefined) {
                localVarQueryParameter['tableKey'] = tableKey;
            }

            if (tablePath !== undefined) {
                localVarQueryParameter['tablePath'] = tablePath;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Creates a temporary table from a SQL statement using the specified connection. Temporary tables are useful for storing intermediate results during complex queries. 
         * @summary Create temporary table (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getTemporarytable: async (projectName: string, connectionName: string, sqlStatement?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getTemporarytable', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getTemporarytable', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/temporaryTable`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sqlStatement !== undefined) {
                localVarQueryParameter['sqlStatement'] = sqlStatement;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all database connections configured for the specified project. Each connection includes its configuration, type, and status information. This endpoint is useful for discovering available data sources within a project. 
         * @summary List project database connections
         * @param {string} projectName Name of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections: async (projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('listConnections', 'projectName', projectName)
            const localVarPath = `/projects/{projectName}/connections`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all schemas (databases) available in the specified connection. Each schema includes metadata such as name, description, and whether it\'s the default schema. This endpoint is useful for exploring the database structure and discovering available data sources. 
         * @summary List database schemas
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchemas: async (projectName: string, connectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('listSchemas', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('listSchemas', 'connectionName', connectionName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/schemas`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all tables and views available in the specified database schema. This endpoint is useful for discovering available data sources and exploring the database structure. The schema must exist in the connection for this operation to succeed. 
         * @summary List tables in database
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} schemaName Name of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables: async (projectName: string, connectionName: string, schemaName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('listTables', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('listTables', 'connectionName', connectionName)
            // verify required parameter 'schemaName' is not null or undefined
            assertParamExists('listTables', 'schemaName', schemaName)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/schemas/{schemaName}/tables`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)))
                .replace(`{${"schemaName"}}`, encodeURIComponent(String(schemaName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes a SQL statement against the specified database connection and returns the results. The results include data, metadata, and execution information. 
         * @summary Execute SQL query
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to execute
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuerydata: async (projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, _options?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('postQuerydata', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('postQuerydata', 'connectionName', connectionName)
            // verify required parameter 'postSqlsourceRequest' is not null or undefined
            assertParamExists('postQuerydata', 'postSqlsourceRequest', postSqlsourceRequest)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/sqlQuery`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_options !== undefined) {
                localVarQueryParameter['options'] = _options;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSqlsourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Malloy source from a SQL statement using the specified database connection. The SQL statement is executed to generate a source definition that can be used in Malloy models. 
         * @summary Create SQL source from statement
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to fetch the SQL source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSqlsource: async (projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('postSqlsource', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('postSqlsource', 'connectionName', connectionName)
            // verify required parameter 'postSqlsourceRequest' is not null or undefined
            assertParamExists('postSqlsource', 'postSqlsourceRequest', postSqlsourceRequest)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/sqlSource`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSqlsourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a temporary table from a SQL statement using the specified database connection. Temporary tables are useful for storing intermediate results during complex queries and data processing workflows. 
         * @summary Create temporary table
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to create the temporary table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTemporarytable: async (projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('postTemporarytable', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('postTemporarytable', 'connectionName', connectionName)
            // verify required parameter 'postSqlsourceRequest' is not null or undefined
            assertParamExists('postTemporarytable', 'postSqlsourceRequest', postSqlsourceRequest)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}/sqlTemporaryTable`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSqlsourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the configuration of an existing database connection. 
         * @summary Update an existing database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection to update
         * @param {UpdateConnectionRequest} updateConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection: async (projectName: string, connectionName: string, updateConnectionRequest: UpdateConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('updateConnection', 'projectName', projectName)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('updateConnection', 'connectionName', connectionName)
            // verify required parameter 'updateConnectionRequest' is not null or undefined
            assertParamExists('updateConnection', 'updateConnectionRequest', updateConnectionRequest)
            const localVarPath = `/projects/{projectName}/connections/{connectionName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new database connection in the specified project. 
         * @summary Create a new database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {Connection} connection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(projectName: string, connectionName: string, connection: Connection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConnection201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnection(projectName, connectionName, connection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.createConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a database connection from the project. 
         * @summary Delete a database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConnection201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnection(projectName, connectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.deleteConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific database connection within a project. This includes connection configuration, credentials (if accessible), and metadata. Useful for inspecting connection settings and troubleshooting connectivity issues. 
         * @summary Get connection details
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnection(projectName, connectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Executes a SQL statement against the specified database connection and returns the results. The query results include data, metadata, and execution information. 
         * @summary Execute SQL query (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getQuerydata(projectName: string, connectionName: string, sqlStatement?: string, _options?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuerydata(projectName, connectionName, sqlStatement, _options, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getQuerydata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Creates a Malloy source from a SQL statement using the specified connection. The SQL statement is executed to generate a source definition that can be used in Malloy models. 
         * @summary Get SQL source (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getSqlsource(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SqlSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSqlsource(projectName, connectionName, sqlStatement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getSqlsource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a table from the specified database schema. This endpoint is useful for discovering available data sources and exploring the database structure. The schema must exist in the connection for this operation to succeed. The tablePath is the full path to the table, including the schema name. 
         * @summary Get table details from database
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} schemaName Name of the schema
         * @param {string} tablePath Full path to the table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTable(projectName: string, connectionName: string, schemaName: string, tablePath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Table>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTable(projectName, connectionName, schemaName, tablePath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getTable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves information about a specific table or view from the database connection. This includes table schema, column definitions, and metadata. The table can be specified by either tableKey or tablePath parameters, depending on the database type. 
         * @summary Get table source information
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [tableKey] Table key
         * @param {string} [tablePath] Table path
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getTablesource(projectName: string, connectionName: string, tableKey?: string, tablePath?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTablesource(projectName, connectionName, tableKey, tablePath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getTablesource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Creates a temporary table from a SQL statement using the specified connection. Temporary tables are useful for storing intermediate results during complex queries. 
         * @summary Create temporary table (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getTemporarytable(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemporaryTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemporarytable(projectName, connectionName, sqlStatement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getTemporarytable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all database connections configured for the specified project. Each connection includes its configuration, type, and status information. This endpoint is useful for discovering available data sources within a project. 
         * @summary List project database connections
         * @param {string} projectName Name of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnections(projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnections(projectName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.listConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all schemas (databases) available in the specified connection. Each schema includes metadata such as name, description, and whether it\'s the default schema. This endpoint is useful for exploring the database structure and discovering available data sources. 
         * @summary List database schemas
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchemas(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchemas(projectName, connectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.listSchemas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all tables and views available in the specified database schema. This endpoint is useful for discovering available data sources and exploring the database structure. The schema must exist in the connection for this operation to succeed. 
         * @summary List tables in database
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} schemaName Name of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTables(projectName: string, connectionName: string, schemaName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Table>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTables(projectName, connectionName, schemaName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.listTables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Executes a SQL statement against the specified database connection and returns the results. The results include data, metadata, and execution information. 
         * @summary Execute SQL query
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to execute
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postQuerydata(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, _options?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postQuerydata(projectName, connectionName, postSqlsourceRequest, _options, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.postQuerydata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Malloy source from a SQL statement using the specified database connection. The SQL statement is executed to generate a source definition that can be used in Malloy models. 
         * @summary Create SQL source from statement
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to fetch the SQL source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSqlsource(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SqlSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSqlsource(projectName, connectionName, postSqlsourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.postSqlsource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a temporary table from a SQL statement using the specified database connection. Temporary tables are useful for storing intermediate results during complex queries and data processing workflows. 
         * @summary Create temporary table
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to create the temporary table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTemporarytable(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemporaryTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTemporarytable(projectName, connectionName, postSqlsourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.postTemporarytable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the configuration of an existing database connection. 
         * @summary Update an existing database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection to update
         * @param {UpdateConnectionRequest} updateConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnection(projectName: string, connectionName: string, updateConnectionRequest: UpdateConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConnection201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnection(projectName, connectionName, updateConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.updateConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * Creates a new database connection in the specified project. 
         * @summary Create a new database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {Connection} connection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(projectName: string, connectionName: string, connection: Connection, options?: RawAxiosRequestConfig): AxiosPromise<CreateConnection201Response> {
            return localVarFp.createConnection(projectName, connectionName, connection, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a database connection from the project. 
         * @summary Delete a database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateConnection201Response> {
            return localVarFp.deleteConnection(projectName, connectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific database connection within a project. This includes connection configuration, credentials (if accessible), and metadata. Useful for inspecting connection settings and troubleshooting connectivity issues. 
         * @summary Get connection details
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise<Connection> {
            return localVarFp.getConnection(projectName, connectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Executes a SQL statement against the specified database connection and returns the results. The query results include data, metadata, and execution information. 
         * @summary Execute SQL query (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getQuerydata(projectName: string, connectionName: string, sqlStatement?: string, _options?: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryData> {
            return localVarFp.getQuerydata(projectName, connectionName, sqlStatement, _options, options).then((request) => request(axios, basePath));
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Creates a Malloy source from a SQL statement using the specified connection. The SQL statement is executed to generate a source definition that can be used in Malloy models. 
         * @summary Get SQL source (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSqlsource(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig): AxiosPromise<SqlSource> {
            return localVarFp.getSqlsource(projectName, connectionName, sqlStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a table from the specified database schema. This endpoint is useful for discovering available data sources and exploring the database structure. The schema must exist in the connection for this operation to succeed. The tablePath is the full path to the table, including the schema name. 
         * @summary Get table details from database
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} schemaName Name of the schema
         * @param {string} tablePath Full path to the table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTable(projectName: string, connectionName: string, schemaName: string, tablePath: string, options?: RawAxiosRequestConfig): AxiosPromise<Table> {
            return localVarFp.getTable(projectName, connectionName, schemaName, tablePath, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information about a specific table or view from the database connection. This includes table schema, column definitions, and metadata. The table can be specified by either tableKey or tablePath parameters, depending on the database type. 
         * @summary Get table source information
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [tableKey] Table key
         * @param {string} [tablePath] Table path
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getTablesource(projectName: string, connectionName: string, tableKey?: string, tablePath?: string, options?: RawAxiosRequestConfig): AxiosPromise<TableSource> {
            return localVarFp.getTablesource(projectName, connectionName, tableKey, tablePath, options).then((request) => request(axios, basePath));
        },
        /**
         * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Creates a temporary table from a SQL statement using the specified connection. Temporary tables are useful for storing intermediate results during complex queries. 
         * @summary Create temporary table (deprecated)
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} [sqlStatement] SQL statement
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getTemporarytable(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig): AxiosPromise<TemporaryTable> {
            return localVarFp.getTemporarytable(projectName, connectionName, sqlStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all database connections configured for the specified project. Each connection includes its configuration, type, and status information. This endpoint is useful for discovering available data sources within a project. 
         * @summary List project database connections
         * @param {string} projectName Name of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Connection>> {
            return localVarFp.listConnections(projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all schemas (databases) available in the specified connection. Each schema includes metadata such as name, description, and whether it\'s the default schema. This endpoint is useful for exploring the database structure and discovering available data sources. 
         * @summary List database schemas
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchemas(projectName: string, connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Schema>> {
            return localVarFp.listSchemas(projectName, connectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all tables and views available in the specified database schema. This endpoint is useful for discovering available data sources and exploring the database structure. The schema must exist in the connection for this operation to succeed. 
         * @summary List tables in database
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {string} schemaName Name of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables(projectName: string, connectionName: string, schemaName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Table>> {
            return localVarFp.listTables(projectName, connectionName, schemaName, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes a SQL statement against the specified database connection and returns the results. The results include data, metadata, and execution information. 
         * @summary Execute SQL query
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to execute
         * @param {string} [_options] Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuerydata(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, _options?: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryData> {
            return localVarFp.postQuerydata(projectName, connectionName, postSqlsourceRequest, _options, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Malloy source from a SQL statement using the specified database connection. The SQL statement is executed to generate a source definition that can be used in Malloy models. 
         * @summary Create SQL source from statement
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to fetch the SQL source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSqlsource(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<SqlSource> {
            return localVarFp.postSqlsource(projectName, connectionName, postSqlsourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a temporary table from a SQL statement using the specified database connection. Temporary tables are useful for storing intermediate results during complex queries and data processing workflows. 
         * @summary Create temporary table
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection
         * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to create the temporary table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTemporarytable(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<TemporaryTable> {
            return localVarFp.postTemporarytable(projectName, connectionName, postSqlsourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the configuration of an existing database connection. 
         * @summary Update an existing database connection
         * @param {string} projectName Name of the project
         * @param {string} connectionName Name of the connection to update
         * @param {UpdateConnectionRequest} updateConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection(projectName: string, connectionName: string, updateConnectionRequest: UpdateConnectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateConnection201Response> {
            return localVarFp.updateConnection(projectName, connectionName, updateConnectionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectionsApi - object-oriented interface
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * Creates a new database connection in the specified project. 
     * @summary Create a new database connection
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {Connection} connection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createConnection(projectName: string, connectionName: string, connection: Connection, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).createConnection(projectName, connectionName, connection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a database connection from the project. 
     * @summary Delete a database connection
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).deleteConnection(projectName, connectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific database connection within a project. This includes connection configuration, credentials (if accessible), and metadata. Useful for inspecting connection settings and troubleshooting connectivity issues. 
     * @summary Get connection details
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnection(projectName: string, connectionName: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getConnection(projectName, connectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Executes a SQL statement against the specified database connection and returns the results. The query results include data, metadata, and execution information. 
     * @summary Execute SQL query (deprecated)
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {string} [sqlStatement] SQL statement
     * @param {string} [_options] Options
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getQuerydata(projectName: string, connectionName: string, sqlStatement?: string, _options?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getQuerydata(projectName, connectionName, sqlStatement, _options, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Creates a Malloy source from a SQL statement using the specified connection. The SQL statement is executed to generate a source definition that can be used in Malloy models. 
     * @summary Get SQL source (deprecated)
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {string} [sqlStatement] SQL statement
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getSqlsource(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getSqlsource(projectName, connectionName, sqlStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a table from the specified database schema. This endpoint is useful for discovering available data sources and exploring the database structure. The schema must exist in the connection for this operation to succeed. The tablePath is the full path to the table, including the schema name. 
     * @summary Get table details from database
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {string} schemaName Name of the schema
     * @param {string} tablePath Full path to the table
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTable(projectName: string, connectionName: string, schemaName: string, tablePath: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getTable(projectName, connectionName, schemaName, tablePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information about a specific table or view from the database connection. This includes table schema, column definitions, and metadata. The table can be specified by either tableKey or tablePath parameters, depending on the database type. 
     * @summary Get table source information
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {string} [tableKey] Table key
     * @param {string} [tablePath] Table path
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getTablesource(projectName: string, connectionName: string, tableKey?: string, tablePath?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getTablesource(projectName, connectionName, tableKey, tablePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions. Use the POST version instead for better security and functionality.  Creates a temporary table from a SQL statement using the specified connection. Temporary tables are useful for storing intermediate results during complex queries. 
     * @summary Create temporary table (deprecated)
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {string} [sqlStatement] SQL statement
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getTemporarytable(projectName: string, connectionName: string, sqlStatement?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getTemporarytable(projectName, connectionName, sqlStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all database connections configured for the specified project. Each connection includes its configuration, type, and status information. This endpoint is useful for discovering available data sources within a project. 
     * @summary List project database connections
     * @param {string} projectName Name of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnections(projectName: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).listConnections(projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all schemas (databases) available in the specified connection. Each schema includes metadata such as name, description, and whether it\'s the default schema. This endpoint is useful for exploring the database structure and discovering available data sources. 
     * @summary List database schemas
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSchemas(projectName: string, connectionName: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).listSchemas(projectName, connectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all tables and views available in the specified database schema. This endpoint is useful for discovering available data sources and exploring the database structure. The schema must exist in the connection for this operation to succeed. 
     * @summary List tables in database
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {string} schemaName Name of the schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listTables(projectName: string, connectionName: string, schemaName: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).listTables(projectName, connectionName, schemaName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes a SQL statement against the specified database connection and returns the results. The results include data, metadata, and execution information. 
     * @summary Execute SQL query
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to execute
     * @param {string} [_options] Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postQuerydata(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, _options?: string, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).postQuerydata(projectName, connectionName, postSqlsourceRequest, _options, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Malloy source from a SQL statement using the specified database connection. The SQL statement is executed to generate a source definition that can be used in Malloy models. 
     * @summary Create SQL source from statement
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to fetch the SQL source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSqlsource(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).postSqlsource(projectName, connectionName, postSqlsourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a temporary table from a SQL statement using the specified database connection. Temporary tables are useful for storing intermediate results during complex queries and data processing workflows. 
     * @summary Create temporary table
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection
     * @param {PostSqlsourceRequest} postSqlsourceRequest SQL statement to create the temporary table
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTemporarytable(projectName: string, connectionName: string, postSqlsourceRequest: PostSqlsourceRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).postTemporarytable(projectName, connectionName, postSqlsourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the configuration of an existing database connection. 
     * @summary Update an existing database connection
     * @param {string} projectName Name of the project
     * @param {string} connectionName Name of the connection to update
     * @param {UpdateConnectionRequest} updateConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateConnection(projectName: string, connectionName: string, updateConnectionRequest: UpdateConnectionRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).updateConnection(projectName, connectionName, updateConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

